{"config":{"lang":["pt"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Doc Datalake Format Explorer","text":""},{"location":"#descricao","title":"Descri\u00e7\u00e3o","text":"<p>O projeto consiste em coletar dados de uma API do Spotify, transformar os dados em diferentes formatos e armazenar em um bucket na AWS.</p>"},{"location":"#fluxo","title":"Fluxo","text":"<pre><code>flowchart LR\n    subgraph pipeline[Pipeline]\n        A[Manager Spotify: Coleta de Dados] --&gt;|Extrai dados| B(Manager Pandas: Converte Formatos)\n        E[Pipeline: Analise] --&gt; |Gera um analise.LOG| D2[Local]\n        B --&gt;|Converte p/ CSV| C[Load: Salva no Bucket]\n        B --&gt;|Converte p/ Parquet| C[Manager AWS: Salva no Bucket]\n        B --&gt;|Converte p/ JSON| C[Manager AWS: Salva no Bucket]\n        B --&gt;|Converte p/ XLS| C[Manager AWS: Salva no Bucket]\n        C --&gt;|Salva como CSV| D1[Bucket AWS]\n        C --&gt;|Salva como Parquet| D1[Bucket AWS]\n        C --&gt;|Salva como JSON| D1[Bucket AWS]\n        C --&gt;|Salva como XLS| D1[Bucket AWS]\n    end</code></pre>"},{"location":"#modulos-do-manager_spotify","title":"M\u00f3dulos do manager_spotify","text":"<p>Obt\u00e9m o access token do Spotify.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Access token.</p> Source code in <code>app/ETL/manager_spotify.py</code> <pre><code>def get_spotify_access_token() -&gt; str:\n\"\"\"\n    Obt\u00e9m o access token do Spotify.\n\n    Returns:\n        str: Access token.\n    \"\"\"\n    AUTH_URL = \"https://accounts.spotify.com/api/token\"\n    auth_header = base64.b64encode(\n        f\"{SPOTIFY_CLIENT_ID}:{SPOTIFY_CLIENT_SECRET}\".encode(\"utf-8\")\n    ).decode(\"utf-8\")\n    headers = {\"Authorization\": f\"Basic {auth_header}\"}\n    data = {\"grant_type\": \"client_credentials\"}\n    response = httpx.post(AUTH_URL, headers=headers, data=data)\n    token_response_data = response.json()\n    print(f\"[INFO] Access token: {token_response_data['access_token']}\")\n    return token_response_data[\"access_token\"]\n</code></pre> <p>Procura por um artista no Spotify e retorna o ID do primeiro resultado.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Nome do artista.</p> required <code>token</code> <code>str</code> <p>Access token.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>ID do artista.</p> Source code in <code>app/ETL/manager_spotify.py</code> <pre><code>def search_artist(name: str, token: str) -&gt; str:\n\"\"\"\n    Procura por um artista no Spotify e retorna o ID do primeiro resultado.\n\n    Args:\n        name (str): Nome do artista.\n        token (str): Access token.\n\n    Returns:\n        str: ID do artista.\n    \"\"\"\n    BASE_URL = \"https://api.spotify.com/v1/search\"\n    headers = {\"Authorization\": f\"Bearer {token}\"}\n    params = {\"q\": name, \"type\": \"artist\", \"limit\": 1}\n    response = httpx.get(BASE_URL, headers=headers, params=params)\n    data = response.json()\n    return data[\"artists\"][\"items\"][0][\"id\"]\n</code></pre> <p>Obt\u00e9m os \u00e1lbuns de um artista.</p> <p>Parameters:</p> Name Type Description Default <code>artist_id</code> <code>str</code> <p>ID do artista.</p> required <code>token</code> <code>str</code> <p>Access token.</p> required <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>Lista de objetos AlbumDetails.</p> Source code in <code>app/ETL/manager_spotify.py</code> <pre><code>def get_artist_albums(artist_id: str, token: str) -&gt; list:\n\"\"\"\n    Obt\u00e9m os \u00e1lbuns de um artista.\n\n    Args:\n        artist_id (str): ID do artista.\n        token (str): Access token.\n\n    Returns:\n        list: Lista de objetos AlbumDetails.\n    \"\"\"\n    BASE_URL = f\"https://api.spotify.com/v1/artists/{artist_id}/albums\"\n    headers = {\"Authorization\": f\"Bearer {token}\"}\n    response = httpx.get(BASE_URL, headers=headers)\n    albums_data = response.json()[\"items\"]\n    return [\n        AlbumDetails(\n            id=album[\"id\"],\n            name=album[\"name\"],\n            release_date=album.get(\"release_date\", None),\n            total_tracks=album[\"total_tracks\"],\n        )\n        for album in albums_data\n    ]\n</code></pre> <p>Obt\u00e9m as m\u00fasicas de um \u00e1lbum.</p> <p>Parameters:</p> Name Type Description Default <code>album_id</code> <code>str</code> <p>ID do \u00e1lbum.</p> required <code>token</code> <code>str</code> <p>Access token.</p> required <p>Returns:</p> Name Type Description <code>list</code> <code>list[TrackDetails]</code> <p>Lista de objetos TrackDetails.</p> Source code in <code>app/ETL/manager_spotify.py</code> <pre><code>def get_album_tracks(album_id: str, token: str) -&gt; list[TrackDetails]:\n\"\"\"\n    Obt\u00e9m as m\u00fasicas de um \u00e1lbum.\n\n    Args:\n        album_id (str): ID do \u00e1lbum.\n        token (str): Access token.\n\n    Returns:\n        list: Lista de objetos TrackDetails.\n    \"\"\"\n    BASE_URL = f\"https://api.spotify.com/v1/albums/{album_id}/tracks\"\n    headers = {\"Authorization\": f\"Bearer {token}\"}\n    response = httpx.get(BASE_URL, headers=headers)\n    tracks_data = response.json()[\"items\"]\n    return [\n        TrackDetails(\n            id=track[\"id\"],\n            name=track[\"name\"],\n            duration_ms=track[\"duration_ms\"],\n            release_date=track.get(\"release_date\", \"N/A\"),\n            popularity=track.get(\"popularity\", 0),\n            track_ids=[],\n        )\n        for track in tracks_data\n    ]\n</code></pre> <p>Obt\u00e9m todos os detalhes de um artista.</p> <p>Parameters:</p> Name Type Description Default <code>artist_name</code> <code>str</code> <p>Nome do artista.</p> required <p>Returns:</p> Name Type Description <code>list</code> <code>list[CompleteArtistDetails]</code> <p>Lista de objetos CompleteArtistDetails.</p> Source code in <code>app/ETL/manager_spotify.py</code> <pre><code>def get_all_artist_details(artist_name: str) -&gt; list[CompleteArtistDetails]:\n\"\"\"\n    Obt\u00e9m todos os detalhes de um artista.\n\n    Args:\n        artist_name (str): Nome do artista.\n\n    Returns:\n        list: Lista de objetos CompleteArtistDetails.\n    \"\"\"\n    token = get_spotify_access_token()\n    artist_id = search_artist(artist_name, token)\n    albums = get_artist_albums(artist_id, token)\n    all_tracks = []\n\n    for album in albums:\n        tracks = get_album_tracks(album.id, token)\n        for track in tracks:\n            all_tracks.append(\n                CompleteArtistDetails(\n                    artist=artist_name,\n                    artist_id=artist_id,\n                    album=album.name,\n                    track=track.name,\n                    minutes=track.duration_ms / 60000,  # Convert ms to minutes\n                    release_date=track.release_date,\n                    popularity=track.popularity,\n                )\n            )\n    return all_tracks\n</code></pre> <p>Obt\u00e9m todos os detalhes de um artista.</p> <p>Parameters:</p> Name Type Description Default <code>artist_name</code> <code>str</code> <p>Nome do artista.</p> required <p>Returns:</p> Name Type Description <code>list</code> <code>list[CompleteArtistDetails]</code> <p>Lista de objetos CompleteArtistDetails.</p> Source code in <code>app/ETL/manager_spotify.py</code> <pre><code>def get_all_artist_details(artist_name: str) -&gt; list[CompleteArtistDetails]:\n\"\"\"\n    Obt\u00e9m todos os detalhes de um artista.\n\n    Args:\n        artist_name (str): Nome do artista.\n\n    Returns:\n        list: Lista de objetos CompleteArtistDetails.\n    \"\"\"\n    token = get_spotify_access_token()\n    artist_id = search_artist(artist_name, token)\n    albums = get_artist_albums(artist_id, token)\n    all_tracks = []\n\n    for album in albums:\n        tracks = get_album_tracks(album.id, token)\n        for track in tracks:\n            all_tracks.append(\n                CompleteArtistDetails(\n                    artist=artist_name,\n                    artist_id=artist_id,\n                    album=album.name,\n                    track=track.name,\n                    minutes=track.duration_ms / 60000,  # Convert ms to minutes\n                    release_date=track.release_date,\n                    popularity=track.popularity,\n                )\n            )\n    return all_tracks\n</code></pre>"},{"location":"#modulos-do-manager_polars","title":"M\u00f3dulos do manager_polars","text":"<p>Salva os dados em diferentes formatos.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>List[CompleteArtistDetails]</code> <p>Lista de objetos CompleteArtistDetails.</p> required <code>artist_name</code> <code>str</code> <p>Nome do artista.</p> required Source code in <code>app/ETL/manager_polars.py</code> <pre><code>def save_data_to_formats(data: List[CompleteArtistDetails], artist_name: str):\n\"\"\"\n    Salva os dados em diferentes formatos.\n\n    Args:\n        data (List[CompleteArtistDetails]): Lista de objetos CompleteArtistDetails.\n        artist_name (str): Nome do artista.\n    \"\"\"\n    # Converte os dados (que esperamos ser uma lista de objetos CompleteArtistDetails) em um DataFrame do Polars\n    df = pl.DataFrame([item.model_dump() for item in data])\n\n    # Substitui espa\u00e7os em branco por h\u00edfens e converte para min\u00fasculas\n    artist_name = artist_name.replace(\" \", \"-\").lower()\n\n    # Salva em CSV\n    df.write_csv(f\"data/{artist_name}-data.csv\")\n\n    # Salva em JSON\n    df.write_json(f\"data/{artist_name}-data.json\")\n\n    # Salva em Parquet\n    df.write_parquet(f\"data/{artist_name}-data.parquet\")\n\n    print(f\"[INFO] Data for {artist_name} saved in multiple formats!\")\n</code></pre>"},{"location":"#modulos-do-manager_aws","title":"M\u00f3dulos do manager_aws","text":"<p>Cria um bucket no S3.</p> <p>Parameters:</p> Name Type Description Default <code>bucket_name</code> <code>str</code> <p>Nome do bucket.</p> required Source code in <code>app/ETL/manager_aws.py</code> <pre><code>def create_bucket(bucket_name: str):\n\"\"\"\n    Cria um bucket no S3.\n\n    Args:\n        bucket_name (str): Nome do bucket.\n    \"\"\"\n    try:\n        s3.create_bucket(Bucket=bucket_name)\n        print(f\"[INFO] Bucket {bucket_name} created successfully!\")\n    except Exception as e:\n        print(f\"[ERROR] Failed to create bucket. Reason: {e}\")\n</code></pre> <p>Faz upload de um arquivo para o S3.</p> <p>Parameters:</p> Name Type Description Default <code>file_name</code> <code>str</code> <p>Nome do arquivo.</p> required <code>bucket_name</code> <code>str</code> <p>Nome do bucket.</p> required Source code in <code>app/ETL/manager_aws.py</code> <pre><code>def upload_to_s3(file_name: str, bucket_name: str):\n\"\"\"\n    Faz upload de um arquivo para o S3.\n\n    Args:\n        file_name (str): Nome do arquivo.\n        bucket_name (str): Nome do bucket.\n    \"\"\"\n    try:\n        s3.upload_file(file_name, bucket_name, file_name)\n        print(f\"[INFO] {file_name} uploaded successfully to {bucket_name}!\")\n    except Exception as e:\n        print(f\"[ERROR] Failed to upload {file_name}. Reason: {e}\")\n</code></pre>"},{"location":"#modulos-de-analise","title":"M\u00f3dulos de an\u00e1lise","text":"<p>Analisa e compara o tamanho dos arquivos gerados em diferentes formatos. Recomenda o formato com o menor volume total.</p> Source code in <code>app/pipeline.py</code> <pre><code>def analyze_file_sizes(artist_name: str):\n\"\"\"\n    Analisa e compara o tamanho dos arquivos gerados em diferentes formatos.\n    Recomenda o formato com o menor volume total.\n    \"\"\"\n    # Diret\u00f3rio onde os arquivos est\u00e3o\n    data_dir = \"data\"\n\n    # Nomes dos arquivos\n    csv_file = f\"{artist_name.lower().replace(' ', '-')}-data.csv\"\n    json_file = f\"{artist_name.lower().replace(' ', '-')}-data.json\"\n    parquet_file = f\"{artist_name.lower().replace(' ', '-')}-data.parquet\"\n\n    # Caminhos completos dos arquivos\n    csv_path = os.path.join(data_dir, csv_file)\n    json_path = os.path.join(data_dir, json_file)\n    parquet_path = os.path.join(data_dir, parquet_file)\n\n    # Obt\u00e9m os tamanhos dos arquivos\n    csv_size = os.path.getsize(csv_path)\n    json_size = os.path.getsize(json_path)\n    parquet_size = os.path.getsize(parquet_path)\n\n    # Calcula as somas dos tamanhos\n    total_csv_size = csv_size\n    total_json_size = json_size\n    total_parquet_size = parquet_size\n\n    # Determina o formato com o menor volume total\n    smallest_format = \"CSV\"\n    smallest_size = total_csv_size\n\n    if total_json_size &lt; smallest_size:\n        smallest_format = \"JSON\"\n        smallest_size = total_json_size\n\n    if total_parquet_size &lt; smallest_size:\n        smallest_format = \"Parquet\"\n        smallest_size = total_parquet_size\n\n    # Imprime os resultados\n    logger.info(f\"An\u00e1lise de tamanho dos arquivos para {artist_name}:\")\n    logger.info(f\"Tamanho total do arquivo CSV: {total_csv_size} bytes\")\n    logger.info(f\"Tamanho total do arquivo JSON: {total_json_size} bytes\")\n    logger.info(f\"Tamanho total do arquivo Parquet: {total_parquet_size} bytes\")\n    logger.info(\n        f\"Recomenda\u00e7\u00e3o: Use o formato {smallest_format} com o menor volume total.\"\n    )\n\n    # Retorna o formato recomendado\n    return smallest_format\n</code></pre>"}]}