{"config":{"lang":["pt"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Doc Datalake Format Explorer","text":""},{"location":"#descricao","title":"Descri\u00e7\u00e3o","text":"<p>O projeto consiste em coletar dados de uma API do Spotify, transformar os dados em diferentes formatos e armazenar em um bucket na AWS.</p> <p>O objetivo final \u00e9 fazer uma an\u00e1lise sobre os 3 tipos de arquivo gerado, CSV, Parquet e JSON, e verificar qual o melhor formato para armazenar os dados.</p> <p>A an\u00e1lise final \u00e9 salva em um arquivo do tipo LOG localmente</p>"},{"location":"#fluxo","title":"Fluxo","text":"<pre><code>flowchart LR\n    subgraph pipeline[Pipeline]\n        A[Manager Spotify: Coleta de Dados] --&gt;|Configura API Spotify| B(Handler HTTPX: Realizada Chamada async)\n        B[Handler HTTPX: Realizada Chamada async] --&gt;|Extrai dados| C(Manager Pandas: Converte Formatos)\n        F[Pipeline: Analise] --&gt; |Gera um analise.LOG| D2[Local]\n        C --&gt;|Converte p/ CSV| D[Load: Salva no Bucket]\n        C --&gt;|Converte p/ Parquet| D[Manager AWS: Salva no Bucket]\n        C --&gt;|Converte p/ JSON| D[Manager AWS: Salva no Bucket]\n        D --&gt;|Salva como CSV| E1[Bucket AWS]\n        D --&gt;|Salva como Parquet| E1[Bucket AWS]\n        D --&gt;|Salva como JSON| E1[Bucket AWS]\n    end</code></pre>"},{"location":"#modulo-handler-http","title":"M\u00f3dulo Handler HTTP","text":"<p>Esse m\u00f3dulo foi criado depois para \"desempacotar\" o httpx/requests da aplica\u00e7\u00e3o, assim, caso seja necess\u00e1rio trocar a biblioteca de requisi\u00e7\u00f5es, basta alterar o m\u00f3dulo.</p> <p>Classe HTTPRequest</p> <p>             Bases: <code>BaseModel</code></p> <p>\u00c9 uma classe que representa uma solicita\u00e7\u00e3o HTTP gen\u00e9rica.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>A URL da solicita\u00e7\u00e3o.</p> required <code>method</code> <code>str</code> <p>O m\u00e9todo HTTP a ser usado (padr\u00e3o \u00e9 \"GET\").</p> required <code>headers</code> <code>dict</code> <p>Um dicion\u00e1rio de cabe\u00e7alhos HTTP personalizados.</p> required <code>params</code> <code>dict</code> <p>Um dicion\u00e1rio de par\u00e2metros de consulta.</p> required <code>data</code> <code>dict</code> <p>Um dicion\u00e1rio de dados a serem enviados na solicita\u00e7\u00e3o.</p> required Source code in <code>app/ETL/handler_http.py</code> <pre><code>class HTTPRequest(BaseModel):\n\"\"\"\n    \u00c9 uma classe que representa uma solicita\u00e7\u00e3o HTTP gen\u00e9rica.\n\n    Args:\n        url (str): A URL da solicita\u00e7\u00e3o.\n        method (str): O m\u00e9todo HTTP a ser usado (padr\u00e3o \u00e9 \"GET\").\n        headers (dict): Um dicion\u00e1rio de cabe\u00e7alhos HTTP personalizados.\n        params (dict): Um dicion\u00e1rio de par\u00e2metros de consulta.\n        data (dict): Um dicion\u00e1rio de dados a serem enviados na solicita\u00e7\u00e3o.\n    \"\"\"\n\n    url: str\n    method: HTTPMETHODS = \"GET\"\n    headers: Dict = None\n    params: Dict = None\n    data: Dict = None\n</code></pre> <p>Faz uma solicita\u00e7\u00e3o HTTP gen\u00e9rica.</p> <p>Parameters:</p> Name Type Description Default <code>http_request</code> <code>HTTPRequest</code> <p>Um objeto HTTPRequest contendo os detalhes da solicita\u00e7\u00e3o.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A resposta JSON da solicita\u00e7\u00e3o HTTP.</p> Source code in <code>app/ETL/handler_http.py</code> <pre><code>async def make_http_request(HTTP_request: HTTPRequest) -&gt; dict:\n\"\"\"\n    Faz uma solicita\u00e7\u00e3o HTTP gen\u00e9rica.\n\n    Args:\n        http_request (HTTPRequest): Um objeto HTTPRequest contendo os detalhes da solicita\u00e7\u00e3o.\n\n    Returns:\n        dict: A resposta JSON da solicita\u00e7\u00e3o HTTP.\n    \"\"\"\n    async with httpx.AsyncClient() as client:\n        response = await client.request(\n            HTTP_request.method,\n            HTTP_request.url,\n            headers=HTTP_request.headers,\n            params=HTTP_request.params,\n            data=HTTP_request.data,\n        )\n        response.raise_for_status()\n        return response.json()\n</code></pre>"},{"location":"#modulos-do-manager_spotify","title":"M\u00f3dulos do manager_spotify","text":"<p>Esse m\u00f3dulo foi criado para encapsular as chamadas a API do Spotify, assim, caso seja necess\u00e1rio trocar o dominio, basta alterar o m\u00f3dulo.</p> <p>Obt\u00e9m o access token do Spotify.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Access token.</p> Source code in <code>app/ETL/manager_spotify.py</code> <pre><code>async def get_spotify_access_token() -&gt; str:\n\"\"\"\n    Obt\u00e9m o access token do Spotify.\n\n    Returns:\n        str: Access token.\n    \"\"\"\n    AUTH_URL = \"https://accounts.spotify.com/api/token\"\n    auth_header = base64.b64encode(\n        f\"{SPOTIFY_CLIENT_ID}:{SPOTIFY_CLIENT_SECRET}\".encode(\"utf-8\")\n    ).decode(\"utf-8\")\n    headers = {\"Authorization\": f\"Basic {auth_header}\"}\n    data = {\"grant_type\": \"client_credentials\"}\n\n    # Faz a solicita\u00e7\u00e3o usando o http_handler\n    response = await make_http_request(\n        HTTPRequest(url=AUTH_URL, method=HTTPMETHODS.POST, headers=headers, data=data)\n    )\n    token_response_data = response\n    print(f\"[INFO] Access token: {token_response_data['access_token']}\")\n    return token_response_data[\"access_token\"]\n</code></pre> <p>Procura por um artista no Spotify e retorna o ID do primeiro resultado.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Nome do artista.</p> required <code>token</code> <code>str</code> <p>Access token.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>ID do artista.</p> Source code in <code>app/ETL/manager_spotify.py</code> <pre><code>async def search_artist(name: str, token: str) -&gt; str:\n\"\"\"\n    Procura por um artista no Spotify e retorna o ID do primeiro resultado.\n\n    Args:\n        name (str): Nome do artista.\n        token (str): Access token.\n\n    Returns:\n        str: ID do artista.\n    \"\"\"\n    BASE_URL = \"https://api.spotify.com/v1/search\"\n    headers = {\"Authorization\": f\"Bearer {token}\"}\n    params = {\"q\": name, \"type\": \"artist\", \"limit\": 1}\n\n    # Faz a solicita\u00e7\u00e3o usando o http_handler\n    response = await make_http_request(\n        HTTPRequest(\n            url=BASE_URL, method=HTTPMETHODS.GET, headers=headers, params=params\n        )\n    )\n    data = response\n    return data[\"artists\"][\"items\"][0][\"id\"]\n</code></pre> <p>Retorna um objeto do tipo ArtistDetails</p> <p>             Bases: <code>BaseModel</code></p> <p>Modelo para os detalhes de um artista.</p> Source code in <code>app/models/spotify_models.py</code> <pre><code>class ArtistDetails(BaseModel):\n\"\"\"\n    Modelo para os detalhes de um artista.\n    \"\"\"\n\n    id: str\n    name: str\n    albums: List[AlbumDetails]\n</code></pre> <p>Obt\u00e9m os \u00e1lbuns de um artista.</p> <p>Parameters:</p> Name Type Description Default <code>artist_id</code> <code>str</code> <p>ID do artista.</p> required <code>token</code> <code>str</code> <p>Access token.</p> required <p>Returns:</p> Type Description <code>List[AlbumDetails]</code> <p>List[AlbumDetails]: Lista de objetos AlbumDetails.</p> Source code in <code>app/ETL/manager_spotify.py</code> <pre><code>async def get_artist_albums(artist_id: str, token: str) -&gt; List[AlbumDetails]:\n\"\"\"\n    Obt\u00e9m os \u00e1lbuns de um artista.\n\n    Args:\n        artist_id (str): ID do artista.\n        token (str): Access token.\n\n    Returns:\n        List[AlbumDetails]: Lista de objetos AlbumDetails.\n    \"\"\"\n    BASE_URL = f\"https://api.spotify.com/v1/artists/{artist_id}/albums\"\n    headers = {\"Authorization\": f\"Bearer {token}\"}\n\n    # Faz a solicita\u00e7\u00e3o usando o http_handler\n    response = await make_http_request(\n        HTTPRequest(url=BASE_URL, method=HTTPMETHODS.GET, headers=headers)\n    )\n    albums_data = response[\"items\"]\n    return [\n        AlbumDetails(\n            id=album[\"id\"],\n            name=album[\"name\"],\n            release_date=album.get(\"release_date\", None),\n            total_tracks=album[\"total_tracks\"],\n        )\n        for album in albums_data\n    ]\n</code></pre> <p>Retorna um objeto do tipo TrackDetails</p> <p>             Bases: <code>BaseModel</code></p> <p>Modelo para os detalhes de uma faixa.</p> Source code in <code>app/models/spotify_models.py</code> <pre><code>class TrackDetails(BaseModel):\n\"\"\"\n    Modelo para os detalhes de uma faixa.\n    \"\"\"\n\n    name: str\n    duration_ms: int\n    release_date: str\n    popularity: int\n    track_ids: list  # Lista de IDs das faixas\n</code></pre> <p>Obt\u00e9m as m\u00fasicas de um \u00e1lbum.</p> <p>Parameters:</p> Name Type Description Default <code>album_id</code> <code>str</code> <p>ID do \u00e1lbum.</p> required <code>token</code> <code>str</code> <p>Access token.</p> required <p>Returns:</p> Type Description <code>List[TrackDetails]</code> <p>List[TrackDetails]: Lista de objetos TrackDetails.</p> Source code in <code>app/ETL/manager_spotify.py</code> <pre><code>async def get_album_tracks(album_id: str, token: str) -&gt; List[TrackDetails]:\n\"\"\"\n    Obt\u00e9m as m\u00fasicas de um \u00e1lbum.\n\n    Args:\n        album_id (str): ID do \u00e1lbum.\n        token (str): Access token.\n\n    Returns:\n        List[TrackDetails]: Lista de objetos TrackDetails.\n    \"\"\"\n    BASE_URL = f\"https://api.spotify.com/v1/albums/{album_id}/tracks\"\n    headers = {\"Authorization\": f\"Bearer {token}\"}\n\n    # Faz a solicita\u00e7\u00e3o usando o http_handler\n    response = await make_http_request(\n        HTTPRequest(url=BASE_URL, method=HTTPMETHODS.GET, headers=headers)\n    )\n    tracks_data = response[\"items\"]\n    return [\n        TrackDetails(\n            id=track[\"id\"],\n            name=track[\"name\"],\n            duration_ms=track[\"duration_ms\"],\n            release_date=track.get(\"release_date\", \"N/A\"),\n            popularity=track.get(\"popularity\", 0),\n            track_ids=[],\n        )\n        for track in tracks_data\n    ]\n</code></pre> <p>Retorna um objeto do tipo AlbumDetails</p> <p>             Bases: <code>BaseModel</code></p> <p>Modelo para os detalhes de um \u00e1lbum.</p> Source code in <code>app/models/spotify_models.py</code> <pre><code>class AlbumDetails(BaseModel):\n\"\"\"\n    Modelo para os detalhes de um \u00e1lbum.\n    \"\"\"\n\n    id: str\n    name: str\n    release_date: Optional[str]\n    total_tracks: int\n    tracks: Optional[List[TrackDetails]] = []\n</code></pre> <p>Obt\u00e9m todos os detalhes de um artista.</p> <p>Parameters:</p> Name Type Description Default <code>artist_name</code> <code>str</code> <p>Nome do artista.</p> required <p>Returns:</p> Type Description <code>List[CompleteArtistDetails]</code> <p>List[CompleteArtistDetails]: Lista de objetos CompleteArtistDetails.</p> Source code in <code>app/ETL/manager_spotify.py</code> <pre><code>async def get_all_artist_details(artist_name: str) -&gt; List[CompleteArtistDetails]:\n\"\"\"\n    Obt\u00e9m todos os detalhes de um artista.\n\n    Args:\n        artist_name (str): Nome do artista.\n\n    Returns:\n        List[CompleteArtistDetails]: Lista de objetos CompleteArtistDetails.\n    \"\"\"\n    token = await get_spotify_access_token()\n    artist_id = await search_artist(artist_name, token)\n    albums = await get_artist_albums(artist_id, token)\n    all_tracks = []\n\n    for album in albums:\n        tracks = await get_album_tracks(album.id, token)\n        for track in tracks:\n            all_tracks.append(\n                CompleteArtistDetails(\n                    artist=artist_name,\n                    artist_id=artist_id,\n                    album=album.name,\n                    track=track.name,\n                    minutes=track.duration_ms / 60000,  # Convert ms to minutes\n                    release_date=track.release_date,\n                    popularity=track.popularity,\n                )\n            )\n    return all_tracks\n</code></pre> <p>Retorna um objeto do tipo CompleteArtistDetails</p> <p>             Bases: <code>BaseModel</code></p> <p>Modelo para os detalhes completos de um artista.</p> Source code in <code>app/models/spotify_models.py</code> <pre><code>class CompleteArtistDetails(BaseModel):\n\"\"\"\n    Modelo para os detalhes completos de um artista.\n    \"\"\"\n\n    artist: str\n    artist_id: str\n    album: str\n    track: str\n    minutes: float\n    release_date: str\n    popularity: int\n</code></pre>"},{"location":"#modulos-do-manager_polars","title":"M\u00f3dulos do manager_polars","text":"<p>Esse m\u00f3dulo foi criado para encapsular as chamadas a API do Pandas e Polars, assim, caso seja necess\u00e1rio trocar a biblioteca de manipula\u00e7\u00e3o de dados, basta alterar o m\u00f3dulo.</p> <p>Salva os dados em diferentes formatos.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>List[CompleteArtistDetails]</code> <p>Lista de objetos CompleteArtistDetails.</p> required <code>artist_name</code> <code>str</code> <p>Nome do artista.</p> required Source code in <code>app/ETL/manager_polars.py</code> <pre><code>def save_data_to_formats(data: List[CompleteArtistDetails], artist_name: str):\n\"\"\"\n    Salva os dados em diferentes formatos.\n\n    Args:\n        data (List[CompleteArtistDetails]): Lista de objetos CompleteArtistDetails.\n        artist_name (str): Nome do artista.\n    \"\"\"\n    # Converte os dados (que esperamos ser uma lista de objetos CompleteArtistDetails) em um DataFrame do Polars\n    df = pl.DataFrame([item.model_dump() for item in data])\n\n    # Substitui espa\u00e7os em branco por h\u00edfens e converte para min\u00fasculas\n    artist_name = artist_name.replace(\" \", \"-\").lower()\n\n    # Salva em CSV\n    df.write_csv(f\"data/{artist_name}-data.csv\")\n\n    # Salva em JSON\n    df.write_json(f\"data/{artist_name}-data.json\")\n\n    # Salva em Parquet\n    df.write_parquet(f\"data/{artist_name}-data.parquet\")\n\n    print(f\"[INFO] Data for {artist_name} saved in multiple formats!\")\n</code></pre>"},{"location":"#modulos-do-manager_aws","title":"M\u00f3dulos do manager_aws","text":"<p>Esse m\u00f3dulo foi criado para encapsular as chamadas a API do AWS, assim, caso seja necess\u00e1rio trocar o provedor de armazenamento, basta alterar o m\u00f3dulo.</p> <p>Cria um bucket no S3.</p> <p>Parameters:</p> Name Type Description Default <code>bucket_name</code> <code>str</code> <p>Nome do bucket.</p> required Source code in <code>app/ETL/manager_aws.py</code> <pre><code>def create_bucket(bucket_name: str):\n\"\"\"\n    Cria um bucket no S3.\n\n    Args:\n        bucket_name (str): Nome do bucket.\n    \"\"\"\n    try:\n        s3.create_bucket(Bucket=bucket_name)\n        print(f\"[INFO] Bucket {bucket_name} created successfully!\")\n    except Exception as e:\n        print(f\"[ERROR] Failed to create bucket. Reason: {e}\")\n</code></pre> <p>Faz upload de um arquivo para o S3.</p> <p>Parameters:</p> Name Type Description Default <code>file_name</code> <code>str</code> <p>Nome do arquivo.</p> required <code>bucket_name</code> <code>str</code> <p>Nome do bucket.</p> required Source code in <code>app/ETL/manager_aws.py</code> <pre><code>def upload_to_s3(file_name: str, bucket_name: str):\n\"\"\"\n    Faz upload de um arquivo para o S3.\n\n    Args:\n        file_name (str): Nome do arquivo.\n        bucket_name (str): Nome do bucket.\n    \"\"\"\n    try:\n        s3.upload_file(file_name, bucket_name, file_name)\n        print(f\"[INFO] {file_name} uploaded successfully to {bucket_name}!\")\n    except Exception as e:\n        print(f\"[ERROR] Failed to upload {file_name}. Reason: {e}\")\n</code></pre>"},{"location":"#modulos-de-analise","title":"M\u00f3dulos de an\u00e1lise","text":"<p>Esse m\u00f3dulo foi criado para fazer a an\u00e1lise final dos tipos de arquivo</p> <p>Analisa e compara o tamanho dos arquivos gerados em diferentes formatos. Recomenda o formato com o menor volume total.</p> Source code in <code>app/pipeline.py</code> <pre><code>async def analyze_file_sizes(artist_name: str):\n\"\"\"\n    Analisa e compara o tamanho dos arquivos gerados em diferentes formatos.\n    Recomenda o formato com o menor volume total.\n    \"\"\"\n    # Diret\u00f3rio onde os arquivos est\u00e3o\n    data_dir = \"data\"\n\n    # Nomes dos arquivos\n    csv_file = f\"{artist_name.lower().replace(' ', '-')}-data.csv\"\n    json_file = f\"{artist_name.lower().replace(' ', '-')}-data.json\"\n    parquet_file = f\"{artist_name.lower().replace(' ', '-')}-data.parquet\"\n\n    # Caminhos completos dos arquivos\n    csv_path = os.path.join(data_dir, csv_file)\n    json_path = os.path.join(data_dir, json_file)\n    parquet_path = os.path.join(data_dir, parquet_file)\n\n    # Obt\u00e9m os tamanhos dos arquivos\n    csv_size = os.path.getsize(csv_path)\n    json_size = os.path.getsize(json_path)\n    parquet_size = os.path.getsize(parquet_path)\n\n    # Calcula as somas dos tamanhos\n    total_csv_size = csv_size\n    total_json_size = json_size\n    total_parquet_size = parquet_size\n\n    # Determina o formato com o menor volume total\n    smallest_format = \"CSV\"\n    smallest_size = total_csv_size\n\n    if total_json_size &lt; smallest_size:\n        smallest_format = \"JSON\"\n        smallest_size = total_json_size\n\n    if total_parquet_size &lt; smallest_size:\n        smallest_format = \"Parquet\"\n        smallest_size = total_parquet_size\n\n    # Imprime os resultados\n    logger.info(f\"An\u00e1lise de tamanho dos arquivos para {artist_name}:\")\n    logger.info(f\"Tamanho total do arquivo CSV: {total_csv_size} bytes\")\n    logger.info(f\"Tamanho total do arquivo JSON: {total_json_size} bytes\")\n    logger.info(f\"Tamanho total do arquivo Parquet: {total_parquet_size} bytes\")\n    logger.info(\n        f\"Recomenda\u00e7\u00e3o: Use o formato {smallest_format} com o menor volume total.\"\n    )\n\n    # Retorna o formato recomendado\n    return smallest_format\n</code></pre>"}]}